---
title: User Permissions
---

The Merchant Center allows configuring permissions based on a userâ€™s team. Each teams belong to one organization. While each organization can have as numerous teams and a user can belong to multiple teams across one or different organizations.

More information about the [User Permission Concepts](https://docs.commercetools.com/merchant-center/user-permissions.html).

# Types of permissions

The Merchant Center loads and provides different types of permissions to be used within a Custom Application.

## General permissions

General permissions are bound to a resource and grant either view or manage  access. Whenever a user has manage access the respective view access is granted implicitly.

A general permission is represented as a `String` with a prefix of `View` or `Manage`, followed by one of the following resource names:

- `Products`
- `Categories`
- `Customers`
- `CustomerGroups`
- `Orders`
- `ProductDiscounts`
- `CartDiscounts`
- `DiscountCodes`
- `ProjectSettings`
- `ProductTypes`
- `DeveloperSettings`

## Action rights

Action rights can be used to constrain a granted general permission. As manage access to products can be limited by not allowing publishing of products for a team.

An action right is represented as an object with the shape `{ group: string, name: string }`. The `group` relates to the permission while the `name` is the action right itself. Currently the following action rights for the `group: 'products'` exist:

- `PublishProducts`
- `UnpublishProducts`
- `AddPrices`
- `EditPrices`
- `DeletePrices`
- `DeleteProducts`
- `AddProducts`

# Using configured permissions within a Custom Application

The [`permissions`](https://github.com/commercetools/merchant-center-application-kit/blob/master/packages/permissions/README.md)-package should be used to integrate configured permissions within a Custom Application. It offers React components, higher-order component and a hook.

- `useIsAuthorized()`
- `injectAuthorized()`
- `<RestrictedByPermissions>`

## `useIsAuthorized(options)`

A React hook to evaluate passed in demanded permissions against the applied ones for the user's team.

### Supported arguments

- `demandedPermissions`: an array of `Permission`, requested for the child component to
  be allowed to render
- `demandedAtionRights`: (_optional_) an array of action rights

```jsx
import { PERMISSIONS } from './constants/permissions.js';

const ExampleComponent = () => {
  const canManageProducts = useIsAuthorized({
    demandedPermissions: [PERMISSIONS.ManageProducts],
  });

  return <span>{ canManageProducts ? 'Authorized' : 'Not authorized' }</span>;
};
```

## `injectAuthorized(permissions, [options])`

A React higher-order component to inject the evaluation of demanded permission against the applied ones into a base component.

### Supported arguments

- `permissions`: an array of demanded general permissions
- `options` (_optional_)
  - `actionRights`: (_optional_) an array of action rights - if passed both, general permissions and action rights needs to be applied to the user's team

```jsx
const InputField = props => (
  <Input
    disabled={!props.isAuthorized}
  />
);

export default injectAuthorized([PERMISSIONS.ViewProducts])(
  InputField
);
```

## `<RestrictedByPermissions>`

A React component which renders its children if the demanded permissions
match, otherwise the passed fallback component.

### Supported props

- `permissions`: an array of demanded general permissions
- `actionRights`: (_optional_) an array of demanded action rights
- `unauthorizedComponent`: (_optional_) a function return an React element to be
  rendered in case the permissions do not match
- `render`: (_optional_) a function returning an React element or a node to be
  rendered in case the permissions match
  - Note: when a function is passed it gets invoked with an object
    containing `isAuthorized` for example `({ isAuthorized }) => <div />`
- `children`: (_optional_) a function returning an React element or a node to be
  rendered in case the permissions match
  - Note: when a function is passed it is invoked with an object
    containing `isAuthorized` for example `({ isAuthorized }) => <div />`

```jsx
<RestrictedByPermissions permissions={[PERMISSIONS.ManageOrders]} unauthorizedComponent={Unauthorized}>
  <MyAuthorizedComponent />
</RestrictedByPermissions>

<RestrictedByPermissions permissions={[PERMISSIONS.ManageOrders]}
  {({ isAuthorized }) => <button disabled={!isAuthorized}>My button</button>}
</RestrictedByPermissions>
```

# Recommendations when working with permissions

## Using a file with constants

It is recommended to store general permissions and action rights used by your application into a `permissions.js` file.

```js
export const ACTION_RIGHTS = {
  PublishProducts: { group: 'products', name: 'PublishProducts' },
};
export const PERMISSIONS = {
  ManageOrders: 'ManageOrders'
}
```

## Evaluate permissions separately

It is recommended to evaluate each permission separately even if the respective APIs allow specifying an array of general permissions and action rights.

```js
// Instead of
const canManageProductsAndViewOrders = useIsAuthorized({
  demandedPermissions: {PERMISSIONS.ViewOrders, PERMISSIONS.ManageProducts},
});

// Apply the hook twice...
const canManageProducts = useIsAuthorized({
  demandedPermissions: [PERMISSIONS.ManageProducts],
});
const canViewOrders = useIsAuthorized({
  demandedPermissions: [PERMISSIONS.ViewOrders],
});
// ...and compose the resulting booleans
const canManageProductsAndViewOrders = canManageProducts && canViewOrders;
```

## Co-locate all evaluations in a shared module

It is recommended to create a shared module containing a React hook, component, or higher-order component to share all permission evaluations across your application.

1. It helps not to spread similar configuration across multiple components
2. Decreases the likelihood of silent bugs due to false configurations
3. Allows changes in your configuration to easily propagate through your application

```js
const usePermissions = () => {
  const canManageProducts = useIsAuthorized({
    demandedPermissions: [PERMISSIONS.ManageProducts],
  });
  const canViewOrders = useIsAuthorized({
    demandedPermissions: [PERMISSIONS.ViewOrders],
  });
  const canPublishProducts = useIsAuthorized({
    demandedPermissions: [PERMISSIONS.ManageOrders],
    demandedActionRights: [ACTION_RIGHTS.PublishProducts],
  });

  return {
    canManageProducts,
    canViewOrders,
    canPublishProducts,
  }
}
```

This React hook can then be used across an entire Custom Application.

```js
const { canManageProducts } = usePermissions();

const InputField = props => (
  <Input
    disabled={!canManageProducts}
  />
);
```

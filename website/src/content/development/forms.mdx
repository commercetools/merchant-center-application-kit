---
title: Forms
---

In previous sections, we learned how to start building the user interface with components and fetching data. One of the most common requirements when implementing a user interface is forms.

To facilitate the development of forms, we provide many ready-to-use input and field components based on the [commercetools Design System](https://github.com/commercetools/ui-kit).

# Form state management

Forms generally consist of a group of inputs that users interact with to trigger actions.
In this process, all user interactions must be tracked, managed, and reflected in the UI. To achieve this, a form must maintain its own state.

[Formik](https://formik.org) is used as the preferred form state management library when building user interfaces.

Formik comes with several built-in features, including validation, array fields, input states, and async submission.

At a bare minimum, implementing a form could look something like this:

<MultiCodeExample>
  <CodeExample path="development/forms/form-state.jsx" />
  <CodeExample path="development/forms/form-state.tsx" />
</MultiCodeExample>


# Field and input components

The commercetools UI Kit library provides several UI components for working with forms. Most of the time you should use the field components as they provide all the recommended features for rendering form elements.

![Form field example](/images/form-field.png 'Form field example')

A field component consists of an input element wrapped with other field elements (such as label, description, error message, hint, and badge).

Depending on the use case, you might want to use a date field, a text field, or a select field. In the UI Kit library, there are many components that cover different use cases. For more information about field and input components check their related packages in the [commercetools/ui-kit](https://github.com/commercetools/ui-kit) repository.

<Info>

All UI Kit field components have a related input component, for example `<TextField>` -> `<TextInput>`.

</Info>

## Accessibility support

All field and input components have built-in support for accessibility features such as aria labels, keyboard navigation, focus management, and error messaging.

<Info>

Testing these field components with [React Testing Library](https://github.com/testing-library/react-testing-library) can be easily done using selectors such as `*ByLabelText` and `*ByRole`.

</Info>

# Form validation

One of the important parts of forms is validation. It is important to validate constraints of forms such as required fields and to check additional semantic requirements (for example, checking that the value is a valid URL).

Aside from client-side validation, forms can also perform asynchronous validation against an API to ensure data correctness before form submission.

For that, Formik allows you to implement a [`validate` function](https://formik.org/docs/api/formik#validate-values-values--formikerrorsvalues--promiseany) that returns an object of errors.

<MultiCodeExample>
  <CodeExample path="development/forms/validate.tsx" />
</MultiCodeExample>



Specifically, the object returned from the `validate` function should contain properties correlating to field names with their values being objects with reasons for the given error. For example:

<MultiCodeExample>
  <CodeExample path="development/forms/validate.jsx" />
</MultiCodeExample>


In this example, we are validating that the `name` field has a required value. If the value is empty (no localized values have been provided), we assign to the `errors.name` property an error object with the error key `missing` set to `true`.

In the field component, you must assign the `errors` and `touched` props which make the field component render an error message, in case one was returned from the `validate` function.

<MultiCodeExample>
  <CodeExample path="development/forms/rendering-errors.jsx" highlightLines={[7,8,9,10]}/>
  <CodeExample path="development/forms/rendering-errors.tsx" highlightLines={[7,8,9,10]}/>
</MultiCodeExample>

<Info>

Error messages are only shown when the `touched` value for the specific field is `true`. This happens whenever the user stops interacting with a field (loses focus). The point here is that as long as the user is interacting with a field for the first time there is no need to show validation.

</Info>

By default, field components have built-in error messages for the `missing` error key. Any other error message can be mapped and rendered using the `renderError` function.

<MultiCodeExample>
  <CodeExample path="development/forms/with-render-error-prop.jsx" highlightLines={[10,11,12,13,14,15,16,17]}/>
  <CodeExample path="development/forms/with-render-error-prop.tsx" highlightLines={[10,11,12,13,14,15,16,17]}/>
</MultiCodeExample>

# Form data conversion

Implementing forms is almost always related to managing data as a bidirectional data flow.

![Form data conversion](/images/form-conversion.png)

To facilitate converting data to and from a form, we recommend defining some conversion functions.

* `docToFormValues`: converts data, for instance, fetched from an API, to the form-specific format.
* `formValuesToDoc`: converts form data back to the original data format, for instance, to be used in an API.

The `docToFormValues` is what you would usually use for initializing the form.

<MultiCodeExample>
  <CodeExample path="development/forms/initialize-with-doc-to-form-values.jsx" highlightLines={[3,8]}/>
  <CodeExample path="development/forms/initialize-with-doc-to-form-values.tsx" highlightLines={[3,12]}/>
</MultiCodeExample>

In our Channels example, it can look something like this:

<MultiCodeExample>
  <CodeExample title="conversions" path="development/forms/doc-to-form-values.jsx" />
  <CodeExample title="conversions" path="development/forms/doc-to-form-values.tsx" />
</MultiCodeExample>

<Info>

Most UI Kit field and input components expose some static methods to ease data conversion and validation. Make sure to check if these methods are available in either the field or the input component.

For example, to validate if a text field is empty, use `TextInput.isEmpty()`.

</Info>

The `formValuesToDoc` on the other end is what you would usually use when submitting the form.

<MultiCodeExample>
  <CodeExample title="conversions" path="development/forms/submitting-with-form-values-to-docs.jsx" highlightLines={[2,7]} />
  <CodeExample title="conversions" path="development/forms/submitting-with-form-values-to-docs.tsx" highlightLines={[3,8]} />
</MultiCodeExample>

In our Channels example, it can look something like this:

<MultiCodeExample>
  <CodeExample title="conversions" path="development/forms/form-values-to-docs.jsx" />
  <CodeExample title="conversions" path="development/forms/form-values-to-docs.tsx" />
</MultiCodeExample>

<Info>

Most of the time you would have simple 1:1 mapping. However, we still recommend using these conversion functions as a best practice and to help decoupling the data transformation logic from the form component.

For instance, the form might only need a couple of fields even though the data object has many more. By being explicit in the conversion, we ensure that only the necessary data is passed to the form.

</Info>

# Building a form page

Let's apply what we just learned in our `Channels` application, as we might want to add a page to view and manage a Channel's details.

Given that we might want to allow creating new channels and updating existing ones, there will be two different pages with the same form components. Therefore, we can implement the form as a component and re-use it in both the create and details pages. The only difference is that the form for the create page will be initially empty and the form for the details page will have some data.

<MultiCodeExample>
  <CodeExample title="channels-form" path="development/forms/channels-form.jsx" />
  <CodeExample title="channels-form" path="development/forms/channels-form.tsx" />
</MultiCodeExample>

Now that we have defined our form component, we can implement the "create" and "details" pages.

The "create" page does not have any initial data, so we can use our conversion function `docToFormValues()` with default values.

<MultiCodeExample>
  <CodeExample title="channels-create" path="development/forms/channels-create.jsx" />
  <CodeExample title="channels-create" path="development/forms/channels-create.tsx" />
</MultiCodeExample>

On the "details" page, we need to fetch the data first, then initialize the form with the data.

<MultiCodeExample>
  <CodeExample title="channels-details" path="development/forms/channels-details.jsx" />
  <CodeExample title="channels-details" path="development/forms/channels-details.tsx" />
</MultiCodeExample>

## Using modal pages

Most of the time a "create" or "details" page with a form can be implemented using either the [FormModalPage](/api-reference/commercetools-frontend-application-components#formmodalpage) or the [CustomFormModalPage](/api-reference/commercetools-frontend-application-components#customformmodalpage) components.

Using these components has the advantage of providing the form control buttons (for example `Cancel` and `Save`) in the correct place, according to our design guidelines.

However, the form component must be defined "outside" of the modal page to be able to pass the necessary functions to the modal page to interact with the form.

Therefore, our Channels form must be refactored to define all the form elements but return them using the function-as-child component pattern.

<MultiCodeExample>
  <CodeExample title="channels-form" path="development/forms/channels-form-with-modal.jsx" />
  <CodeExample title="channels-form" path="development/forms/channels-form-with-modal.tsx" />
</MultiCodeExample>

The Channels pages then can be refactored as following:

<MultiCodeExample>
  <CodeExample title="channels-create" path="development/forms/channels-create-with-modal.jsx" />
  <CodeExample title="channels-create" path="development/forms/channels-create-with-modal.tsx" />
</MultiCodeExample>

<MultiCodeExample>
  <CodeExample title="channels-details" path="development/forms/channels-details-with-modal.jsx" />
  <CodeExample title="channels-details" path="development/forms/channels-details-with-modal.tsx" />
</MultiCodeExample>

## Splitting form fields

Sometimes a form contains many different fields, resulting in the form component to be difficult to read.

One way to improve that is to split the form component into multiple smaller components. As a rule of thumb you can create one separate component for each form field. For example a `<FormChannelNameField>`, a `<FormChannelKeyField>`, and so on.

<Info>

To use the `useField` hook, the form must be wrapped with the `<Formik>` component instead of using the `useFormik` hook, so that the React context is properly defined.

</Info>

As a result, the form component can look like this:

<MultiCodeExample>
  <CodeExample title="channels-form" path="development/forms/split-form-component.jsx" />
  <CodeExample title="channels-form" path="development/forms/split-form-component.tsx" />
</MultiCodeExample>

One of the advantages of splitting up the form fields is to encapsulate the logic. You might notice that we don't explicitly pass any props to these components. Instead, each component can access the form data that they need from the form context, using Formik's `useField` hook.

<MultiCodeExample>
  <CodeExample title="form-channel-name" path="development/forms/form-channel-name.jsx" />
  <CodeExample title="form-channel-name" path="development/forms/form-channel-name.tsx" />
</MultiCodeExample>

The `field` object can be spread to the UI Kit field component (it contains the props like `name`, `onChange`, etc.) and the `meta` object contains things like `touched` and `error` values of the specific field.

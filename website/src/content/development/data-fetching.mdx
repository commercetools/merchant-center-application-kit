---
title: Data Fetching
---

In client-side applications, data fetching is not always easy and it usually involves a lot of boilerplate code around implementation, state management, data normalization, etc.

A Custom Application uses the [Merchant Center API](/concepts/merchant-center-api) to connect to any of the Composable Commerce APIs.

To make it easier to connect to these APIs, we provide some pre-configured HTTP clients for both [GraphQL and REST APIs](/concepts/merchant-center-api#api-gateway-endpoints).

# GraphQL HTTP client

The Composable Commerce APIs and the Merchant Center have first-class support for GraphQL. We strongly recommend building your Custom Application using GraphQL whenever possible.

Custom Applications provide a pre-configured [Apollo GraphQL Client](https://www.apollographql.com/docs/react/) to perform requests to the GraphQL APIs.

<Info>

A custom instance of the Apollo client can be created using the [createApolloClient](/api-reference/commercetools-frontend-application-shell#createapolloclient) function.

</Info>

## Using React hooks

The preferred way of fetching data in a React component is to use [React hooks](https://reactjs.org/docs/hooks-intro.html).

The Apollo Client provides some React hooks to [query data](https://www.apollographql.com/docs/react/data/queries/) and [mutate data](https://www.apollographql.com/docs/react/data/mutations/).

Using the hooks in your React component is as simple as this:

```js title="channels.js" highlightLines="5-9"
import { useQuery } from '@apollo/client/react';
import { GRAPHQL_TARGETS } from '@commercetools-frontend/constants';

const Channels = (props) => {
  const { data } = useQuery(FetchChannelsQuery, {
    context: {
      target: GRAPHQL_TARGETS.COMMERCETOOLS_PLATFORM,
    }
  });

  return (
    <div>
      {/* Do something with `data` */}
    </div>
  );
};
```

Notice here that we define the `context.target`. This is how you configure the [GraphQL target for the Merchant Center API](/concepts/merchant-center-api#graphql).

The available GraphQL targets are exposed as a `GRAPHQL_TARGETS` constant in the [`@commercetools-frontend/constants`](/api-reference/commercetools-frontend-constants) package.

## Using GraphQL documents

In Custom Applications you define your queries and mutations in dedicated `.graphql` files that you can `import` in your component file.

<Info>

Using `.graphql` files is a great way to co-locate your data requirements next to your React component. Furthermore, you can leverage these files to improve the developer experience with editor syntax highlighting, linting, code generation, etc.

</Info>

Let's create one:

```graphql title="fetch-channels.ctp.graphql"
query FetchChannels {
  channels {
    total
    count
    offset
    results {
      id
      key
      roles
      nameAllLocales {
        locale
        value
      }
    }
  }
}
```

And import it from the React component file:

```js
import FetchChannelsQuery from './fetch-channels.ctp.graphql';
```

## Error handling

Of course we need to handle situations where requests fail for whatever reason (network errors, schema validation errors, etc.).

The Apollo Client hooks provide an `error` object that we can use in our component to handle failures.

For example, we can render a content notification error instead of rendering the component.

```js title="channels.js" highlightLines="7,13-19"
import { useQuery } from '@apollo/client/react';
import { GRAPHQL_TARGETS } from '@commercetools-frontend/constants';
import { ContentNotification } from '@commercetools-uikit/notifications';
import Text from '@commercetools-uikit/text';

const Channels = (props) => {
  const { data, error } = useQuery(FetchChannelsQuery, {
    context: {
      target: GRAPHQL_TARGETS.COMMERCETOOLS_PLATFORM,
    }
  });

  if (error) {
    return (
      <ContentNotification type="error">
        <Text.Body>{getErrorMessage(error)}</Text.Body>
      </ContentNotification>
    );
  }

  return (
    <div>
      {/* Do something with `data` */}
    </div>
  );
};
```

For more information about using the `error` from Apollo Client, see [Error handling](https://www.apollographql.com/docs/react/data/error-handling/).

In our case we just want to print the `error.graphQLErrors`. We can attempt to do that by implementing a helper function like this:

```js title="channels.js"
const getErrorMessage = (error) =>
  error.graphQLErrors?.map((e) => e.message).join('\n') || error.message;
```

# REST HTTP client

Some endpoints or APIs might not be available as GraphQL but as a standard HTTP REST endpoint instead.

Custom Applications provide a pre-configured declarative fetching library [`@commercetools-frontend/sdk`](https://www.npmjs.com/package/@commercetools-frontend/sdk), which builds on top of the [JS SDK client](https://commercetools.github.io/nodejs/sdk/api/sdkClient.html) and [Redux](https://redux.js.org/)

The SDK library is built using Redux actions, meaning that you dispatch an action describing the request and the library takes care of handling the request.

```js title="channels.js"
import { useAsyncDispatch, actions } from '@commercetools-frontend/sdk';
import { MC_API_PROXY_TARGETS } from '@commercetools-frontend/constants';

const Channels = (props) => {
  const dispatch = useAsyncDispatch();
  useEffect(() => {
    async function execute() {
      try {
        const result = await dispatch(
          actions.get({
            mcApiProxyTarget: MC_API_PROXY_TARGETS.COMMERCETOOLS_PLATFORM,
            service: 'channels',
          });
        );
        // Update state with `result`
      } catch (error) {
        // Update state with `error`
      }
    }
    execute();
  }, [dispatch])

  return (
    <div>
      {/* Do something with the state */}
    </div>
  );
};
```

Notice here that we define the `mcApiProxyTarget`. This is how you configure the proxy target for the [Merchant Center API](/concepts/merchant-center-api#proxytarget).

The available proxy targets are exposed as a `MC_API_PROXY_TARGETS` constant in the [`@commercetools-frontend/constants`](/api-reference/commercetools-frontend-constants) package.

<Warning>

The SDK library does not include features like data normalization, caching, etc. You will need to build these on your own.

</Warning>

# Custom HTTP client

By default Custom Applications provide pre-configured HTTP clients for [GraphQL](#graphql-http-client) and [REST](#rest-http-client) API requests.

However, you could use any other HTTP client of your choice, for example [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), [Axios](https://axios-http.com/), [SWR](https://swr.vercel.app/), etc.

The main problem with that is the fact that you need to configure these clients on your own, in particular regarding the [HTTP headers that should be sent with every request](/concepts/merchant-center-api#http-headers).

To make it easier to configure your HTTP client with the necessary HTTP headers, we provide some dedicated utility functions, in particular the `executeHttpClientRequest`.

```js
import {
  executeHttpClientRequest,
} from '@commercetools-frontend/application-shell';
```

This function acts as a wrapper to whatever HTTP client is used and provides all the recommended functionalities such as:

- Defining the required/recommended [HTTP headers for the Merchant Center API](/concepts/merchant-center-api#http-headers).
- Automatically renewing the token to access a particular API.

The function accepts an object for the HTTP headers configuration and a callback function to execute the request. The callback function returns the configured HTTP options, including the pre-configured HTTP headers.

```ts
type TOptions = {
  credentials: 'include';

  /**
   * The HTTP headers included by default are:
   * - Accept
   * - Authorization (only in development)
   * - X-Application-Id
   * - X-Correlation-Id
   * - X-Project-Key
   * - X-User-Agent
   */
  headers: THeaders;
};
type TFetcherResponse<Data> = {
  /**
   * The parsed response from the server.
   */
  data: Data;
  /**
   * The HTTP status code from the server response.
   */
  statusCode: number;
  /**
   * Implement a function to access the HTTP headers from the server response.
   */
  getHeader: (headerName: string) => string | null;
}
type TFetcher<Data> = (
  options: TOptions
) => Promise<TFetcherResponse<Data>>;

async function executeHttpClientRequest<Data>(
  config?: TConfig,
  fetcher: TFetcher<Data>
): Promise<Data>;
```

## Example using Fetch

The example below uses the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).

```js highlightLines="9,16-27"
import createHttpUserAgent from '@commercetools/http-user-agent';
import {
  buildApiUrl,
  createHttpClientOptions,
  executeHttpClientRequest,
} from '@commercetools-frontend/application-shell';

const userAgent = createHttpUserAgent({
  name: 'fetch-client',
  version: '1.0.0',
  libraryName: window.app.applicationName,
  contactEmail: 'support@my-company.com',
});

const fetcher = async (url, config = {}) => {
  const data = await executeHttpClientRequest(
    async (options) => {
      const res = await fetch(buildApiUrl(url), options);
      const data = res.json();
      return {
        data,
        statusCode: res.status,
        getHeader: (key) => res.headers.get(key),
      };
    },
    { userAgent, headers: config.headers }
  );
  return data;
};

const Channels = () => {
  useEffect(() => {
    async function execute() {
      try {
        const result = await fetcher('/proxy/ctp/channels');
        // Update state with `result`
      } catch (error) {
        // Update state with `error`
      }
    }
    execute();
  }, [dispatch])
  // ...
};
```

## Example using Axios

The example below uses the [Axios](https://axios-http.com/) HTTP client.

```js highlightLines="10,17-32"
import axios from 'axios';
import createHttpUserAgent from '@commercetools/http-user-agent';
import {
  buildApiUrl,
  createHttpClientOptions,
  executeHttpClientRequest,
} from '@commercetools-frontend/application-shell';

const userAgent = createHttpUserAgent({
  name: 'axios-client',
  version: '1.0.0',
  libraryName: window.app.applicationName,
  contactEmail: 'support@my-company.com',
});

const fetcher = async (url, config = {}) => {
  const data = await executeHttpClientRequest(
    async (options) => {
      const res = await axios(buildApiUrl(url), {
        ...config,
        headers: options.headers,
        withCredentials: options.credentials === 'include',
      });
      const data = res.json();
      return {
        data: res.data,
        statusCode: res.status,
        getHeader: (key) => res.headers[key],
      };
    },
    { userAgent, headers: config.headers }
  );
  return data;
};

const Channels = () => {
  useEffect(() => {
    async function execute() {
      try {
        const result = await fetcher('/proxy/ctp/channels');
        // Update state with `result`
      } catch (error) {
        // Update state with `error`
      }
    }
    execute();
  }, [dispatch])
  // ...
};
```

## Example using SWR

The example below uses the [SWR](https://swr.vercel.app/) React hook.

```js highlightLines="10,17-28"
import useSWR from 'swr';
import createHttpUserAgent from '@commercetools/http-user-agent';
import {
  buildApiUrl,
  createHttpClientOptions,
  executeHttpClientRequest,
} from '@commercetools-frontend/application-shell';

const userAgent = createHttpUserAgent({
  name: 'swr-client',
  version: '1.0.0',
  libraryName: window.app.applicationName,
  contactEmail: 'support@my-company.com',
});

const fetcher = async (url, config = {}) => {
  const data = await executeHttpClientRequest(
    async (options) => {
      const res = await fetch(buildApiUrl(url), options);
      const data = res.json();
      return {
        data,
        statusCode: res.status,
        getHeader: (key) => res.headers.get(key),
      };
    },
    { userAgent, headers: config.headers }
  );
  return data;
};

const Channels = () => {
  const { data, error } = useSWR('/proxy/ctp/channels', fetcher);
  // ...
};
```

## Example using Ky

The example below uses the [Ky](https://github.com/sindresorhus/ky) HTTP client.

```js highlightLines="10,17-28"
import ky from 'ky';
import createHttpUserAgent from '@commercetools/http-user-agent';
import {
  buildApiUrl,
  createHttpClientOptions,
  executeHttpClientRequest,
} from '@commercetools-frontend/application-shell';

const userAgent = createHttpUserAgent({
  name: 'ky-client',
  version: '1.0.0',
  libraryName: window.app.applicationName,
  contactEmail: 'support@my-company.com',
});

const fetcher = async (url, config = {}) => {
  const data = await executeHttpClientRequest(
    async (options) => {
      const res = await ky(buildApiUrl(url), options);
      const data = res.json();
      return {
        data,
        statusCode: res.statusCode,
        getHeader: (key) => res.headers.get(key),
      };
    },
    { userAgent, headers: config.headers }
  );
  return data;
};

const Channels = () => {
  const { data, error } = useSWR('/proxy/ctp/channels', fetcher);
  // ...
};
```

# Advanced usage

## Using Connector Hooks

As your data requirements grow, for example by having multiple queries and mutations in a React component, or using the same query in multiple components, you might want to extract your queries into separate reusable hooks.

We recommend extracting the logic into what we call _connector hooks_.

A connector hook is a React hook that implements most of the data requirements (queries and mutations) specific to the use cases where the data should be used.

For example, we can extract the fetching of Channels into a connector hook named `useChannelsFetcher`.
This hook can be put into a file named `use-channels-connector.js`.

```js title="use-channels-connector.js"
import { useQuery } from '@apollo/client/react';
import { GRAPHQL_TARGETS } from '@commercetools-frontend/constants';

export const useChannelsFetcher = () => {
  const { data, error, loading } = useQuery(FetchChannelsQuery, {
    context: {
      target: GRAPHQL_TARGETS.COMMERCETOOLS_PLATFORM,
    }
  });

  return {
    channels: data?.channels,
    error,
    loading,
  };
};
```

<Info>

Note that the `use-channels-connector.js` file can contain multiple connector hooks. For example `useChannelsFetcher`, `useChannelsUpdater`, `useChannelsCreator`, and so on.

</Info>

We would then use our connector hook in the `Channels` component instead of directly using the Apollo Client hooks. Therefore, there is less code in the React component as most of the logic and configuration is abstracted away in the connector hook.

```js title="channels.js" highlightLines="3,6"
import { ContentNotification } from '@commercetools-uikit/notifications';
import Text from '@commercetools-uikit/text';
import { useChannelsFetcher } from '../../hooks/use-channels-connector';

const Channels = (props) => {
  const { channels, error } = useChannelsFetcher();

  if (error) {
    return (
      <ContentNotification type="error">
        <Text.Body>{getErrorMessage(error)}</Text.Body>
      </ContentNotification>
    );
  }

  return (
    <div>
      {/* Do something with `channels` */}
    </div>
  );
};
```

<!-- TODO: ## Using fetch policy -->
<!-- TODO: ## Customizing Apollo Cache -->

## Connecting to an external GraphQL API

In case your Custom Application needs to connect to an [external GraphQL API](/concepts/integrate-with-your-own-api), in addition to the commercetools GraphQL APIs, the Apollo Client needs to be reconfigured to connect to the `/proxy/forward-to` endpoint with the appropriate headers.
This can be achieved by using the `context` option of Apollo Client, which allows passing configuration options to the Apollo Links.

The `@commercetools-frontend/application-shell` package now exposes a [createApolloContextForProxyForwardTo](/api-reference/commercetools-frontend-application-shell#createapollocontextforproxyforwardto) to construct a predefined context object specific to the `/proxy/forward-to`.

```jsx highlightLines="2,10-12"
import {
  createApolloContextForProxyForwardTo,
  useMcQuery,
} from '@commercetools-frontend/application-shell';
import Text from '@commercetools-uikit/text';
import HelloWorldQuery from './hello-world.graphql';

const HelloWorld = () => {
  const { loading, data, error } = useMcQuery(HelloWorldQuery, {
    context: createApolloContextForProxyForwardTo({
      uri: 'https://my-custom-app.com/graphql',
    }),
  });

  if (loading) return 'Loading...';
  if (error) return `Error! ${error.message}`;
  return <Text.Headline as="h1">{data.title}</Text.Headline>;
}
```

## Using file uploads

In case you need to deal with file uploads, you will probably use [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

The `FormData` object can then be sent as the HTTP request body.

It is important to properly configure the `Content-Type` HTTP header, which usually must be set to `multipart/form-data`. However, you also need to provide a `boundary` [directive](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type#directives).

We recommend to omit the `Content-Type` HTTP header in the request and let the browser correctly infer it.

<Info>

When using the [`@commercetools-frontend/sdk`](https://www.npmjs.com/package/@commercetools-frontend/sdk) package, you need to explicitly unset the `Content-Type` HTTP header by passing `null` as value.

```js
{
  'Content-Type': null
}
```

</Info>
